package cli

import (
	"context"
	"log"
	"sync"

	"github.com/aws/aws-sdk-go-v2/aws"
	rtypes "github.com/aws/aws-sdk-go-v2/service/route53/types"
	"github.com/fatih/color"
	"github.com/pedrokiefer/route53copy/pkg/dns"
	"github.com/pedrokiefer/route53copy/pkg/vuln"
	"github.com/spf13/cobra"
)

type vulnerabilityScanApp struct {
	Profile  string
	Zone     string
	AllZones bool
}

func init() {
	rootCmd.AddCommand(newVulnerabiltyScanCommand())
}

var WhiteBold = color.New(color.FgWhite, color.Bold)
var MISCONFIG = color.YellowString("[MISCONFIG]")
var VULN = color.RedString("[VULN]")

func (a *vulnerabilityScanApp) Run(ctx context.Context) error {
	manager := dns.NewRouteManager(ctx, a.Profile, &dns.RouteManagerOptions{
		NoWait: noWait,
	})

	zones := []rtypes.HostedZone{}
	if a.AllZones {
		z, err := manager.ListHostedZones(ctx)
		if err != nil {
			return err
		}
		zones = z
		log.Printf("Scanning %d zones in %s\n", len(zones), a.Profile)
	} else {
		zone, err := manager.GetHostedZone(ctx, a.Zone)
		if err != nil {
			return err
		}
		log.Printf("Scaning zone %s in %s\n", aws.ToString(zone.Name), a.Profile)
		zones = append(zones, zone)
	}

	log.Printf("Fetching records...\n")
	records := sync.Map{}
	concurrentGoroutines := make(chan struct{}, 5)
	var wg sync.WaitGroup
	//map[string][]rtypes.ResourceRecordSet{}
	for _, z := range zones {
		wg.Add(1)
		concurrentGoroutines <- struct{}{}
		go func(z rtypes.HostedZone) {
			defer wg.Done()
			rs, err := manager.GetResourceRecords(ctx, aws.ToString(z.Id))
			if err != nil {
				log.Printf("failed to list records for zone %s: %s", aws.ToString(z.Name), err)
				<-concurrentGoroutines
				return
			}
			records.Store(aws.ToString(z.Name), rs)
			<-concurrentGoroutines
		}(z)
	}
	wg.Wait()

	records.Range(func(k, v interface{}) bool {
		zone := k.(string)
		rs := v.([]rtypes.ResourceRecordSet)
		log.Printf("Checking zone %s:\n", WhiteBold.Sprintf(zone))
		log.Printf(" - %s...\n", WhiteBold.Sprintf("Checking mail vulnerabilities"))
		vuln.MailCheck(ctx, zone, rs)
		log.Printf(" - %s...\n", WhiteBold.Sprintf("Checking subdomain takeover"))
		for _, entry := range rs {
			vuln.SubDomainTakeoverCheck(ctx, zone, entry)
		}
		return true
	})

	return nil
}

func newVulnerabiltyScanCommand() *cobra.Command {
	a := vulnerabilityScanApp{}

	c := &cobra.Command{
		Use:   "vulnerability-scan <profile> [zoneName]",
		Short: "Search all DNS entries in an AWS account for a given key",
		Args:  cobra.MinimumNArgs(1),
		RunE: func(cmd *cobra.Command, args []string) error {
			a.Profile = args[0]
			if len(args) == 2 {
				a.Zone = args[1]
			}
			return a.Run(cmd.Context())
		},
		SilenceErrors: true,
		SilenceUsage:  true,
	}
	f := c.Flags()
	f.BoolVar(&a.AllZones, "a", false, "Scan all zones on current account")
	return c
}
