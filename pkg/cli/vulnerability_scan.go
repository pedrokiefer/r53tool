package cli

import (
	"context"
	"encoding/json"
	"fmt"
	"log"
	"os"
	"sync"
	"time"

	"github.com/aws/aws-sdk-go-v2/aws"
	rtypes "github.com/aws/aws-sdk-go-v2/service/route53/types"
	"github.com/fatih/color"
	"github.com/pedrokiefer/route53copy/pkg/dns"
	"github.com/pedrokiefer/route53copy/pkg/vuln"
	"github.com/spf13/cobra"
)

type vulnerabilityScanApp struct {
	Profile  string
	Zone     string
	AllZones bool
}

func init() {
	rootCmd.AddCommand(newVulnerabiltyScanCommand())
}

var WhiteBold = color.New(color.FgWhite, color.Bold)
var MISCONFIG = color.YellowString("[MISCONFIG]")
var VULN = color.RedString("[VULN]")

func (a *vulnerabilityScanApp) Run(ctx context.Context) error {
	manager := dns.NewRouteManager(ctx, a.Profile, &dns.RouteManagerOptions{
		NoWait: noWait,
	})

	zones := []rtypes.HostedZone{}
	if a.AllZones {
		z, err := manager.ListHostedZones(ctx)
		if err != nil {
			return err
		}
		zones = z
		log.Printf("Scanning %d zones in %s\n", len(zones), a.Profile)
	} else {
		zone, err := manager.GetHostedZone(ctx, a.Zone)
		if err != nil {
			return err
		}
		log.Printf("Scaning zone %s in %s\n", aws.ToString(zone.Name), a.Profile)
		zones = append(zones, zone)
	}

	log.Printf("Fetching records...\n")
	records := sync.Map{}
	concurrentGoroutines := make(chan struct{}, 5)
	var wg sync.WaitGroup
	//map[string][]rtypes.ResourceRecordSet{}
	for _, z := range zones {
		wg.Add(1)
		concurrentGoroutines <- struct{}{}
		go func(z rtypes.HostedZone) {
			defer wg.Done()
			rs, err := manager.GetResourceRecords(ctx, aws.ToString(z.Id))
			if err != nil {
				log.Printf("failed to list records for zone %s: %s", aws.ToString(z.Name), err)
				<-concurrentGoroutines
				return
			}
			zm := vuln.ZoneMeta{
				ZoneID: aws.ToString(z.Id),
				Name:   aws.ToString(z.Name),
			}
			records.Store(zm, rs)
			<-concurrentGoroutines
		}(z)
	}
	wg.Wait()

	findings := []*vuln.Findings{}

	records.Range(func(k, v interface{}) bool {
		zm := k.(vuln.ZoneMeta)
		rs := v.([]rtypes.ResourceRecordSet)
		f := vuln.Scan(ctx, zm, rs)
		findings = append(findings, f)
		return true
	})

	err := writeReport(a.Profile, findings)
	if err != nil {
		log.Printf("failed to write report: %s", err)
	}

	return nil
}

func writeReport(profile string, findings []*vuln.Findings) error {
	filename := fmt.Sprintf("vuln-%s-%s.json", profile, time.Now().Format("2006-01-02-15-04-05"))
	f, err := os.Create(filename)
	if err != nil {
		return err
	}
	defer f.Close()

	err = json.NewEncoder(f).Encode(findings)
	if err != nil {
		return err
	}
	log.Printf("Report written to %s", filename)
	return nil
}

func newVulnerabiltyScanCommand() *cobra.Command {
	a := vulnerabilityScanApp{}

	c := &cobra.Command{
		Use:   "vulnerability-scan <profile> [zoneName]",
		Short: "Search all DNS entries in an AWS account for a given key",
		Args:  cobra.MinimumNArgs(1),
		RunE: func(cmd *cobra.Command, args []string) error {
			a.Profile = args[0]
			if len(args) == 2 {
				a.Zone = args[1]
			}
			return a.Run(cmd.Context())
		},
		SilenceErrors: true,
		SilenceUsage:  true,
	}
	f := c.Flags()
	f.BoolVar(&a.AllZones, "a", false, "Scan all zones on current account")
	return c
}
